## HashMap

首先，在jdk1.7和1.8当中，hashmap结构是不一样的

在1.7中，hashmap的结构为数组加链表、1.8中为数组+链表+红黑树（根据加载因子0.75，当元素个数达到8时会转为红黑树，当减少到6个时会转为链表）。数组里面存的都是key-value这样entry对象（在1.8中为node）。每一个节点都保存了key、value、hash、以及下个节点next。在put的时候，会根据key的hash计算index。因为存在概率性问题，可能会存在key的hash相等的情况，所以链表出现了。hashmap 会把hash值相等的key以链表的方式存在数组的某个位置。

链表插入的方式，在1.7使用的是头插，1.8使用的尾插。

头插：就是新来的值会取代原来的值，原有的值会顺序推到链表中。然而在hashmap扩容的时候，hashmap会根据当前容量和加载因子来判断什么时候扩容。扩容会先创建一个长度为原数组两倍的空数组，因为新数组的长度发生的改变，所以在拷贝元素的时候会重新计算每个key的hash（rehash）。所以原先在某个位置的key在新数组中位置可能会发生变化。

然后再多线程的环境下，在rehash的时候，可能会发生所有key都已经存进去而扩容还没有完成，对于有相同hash值的key来说就有可能会出现环形链表，然后再取数据的时候出现**死循环**。

使用头插会改变链表的顺序，但是使用尾插，在扩容时，会保持链表元素的原本顺序，就不会出现环形链表了。

## ConcurrentHashMap

因为HashMap 是线程不安全的。

1. 可以使用Collections.synchronized(map)创建一个线程安全的map集合，
2. 使用HashTable。
3. 使用ConcurrentHashMap

不过出于线程并发的原因，一般都是使用ConcurrentHashMap。因为使用 Collections.synchronized(map) 得到的synchronizedMap，对map进行操作的时候就会对方法上锁。

HashTable它在对数据操作的时候就都会上锁，所以效率很低。

HashTable不允许键或值为null，hashmap允许；因为HashTable使用的是**安全失败机制**（fail-safe），这种机制会使你此次读到的数据不一定是最新的。如果你是用null，就会使得其无法判断对应的key是不存在还是空，因为无法再次调用contain（key）来对key是否存在进行判断，ConcurrentHashMap同理。

fail-fast：快速失败

java集合中的一种机制，在使用迭代器对集合进行遍历的时，如果遍历过程中对集合的内容进行了修改（增删改），则会抛出异常。

